<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <link rel="icon" type="image/png" href="/assets/favicon.png"/>
  <meta name="generator" content="pandoc" />
  <meta name="author" content="Raphaël Proust" />
  <title>Dromedary and a half - Odds</title>
  <link rel="stylesheet" href="/assets/style.css" />
</head>
<body>
<header>
<nav>
	<a href="/code/index.html">On code</a> |
	<a href="/games/index.html">On games</a> |
	<a href="/misc/index.html">Miscellanées</a> |
	<a href="/about.html">About</a>
</nav>
</header>
<div id="content">
<div id="header">
<h1 class="title">Odds</h1>
</div>
<p><a href="https://github.com/raphael-proust/odds">Odds (OCaml Dice Dice Something)</a> is a library for rolling dice. It provides deterministic rolls and combinators for common operations.</p>
<p><a href="https://github.com/raphael-proust/odds">Github repository</a><br />
<a href="/code/odds/index.html">Documentation</a></p>
<p>Odds is distributed with the companion program <code>roll</code> which interprets command line arguments as a dice expression, evaluates it and prints the result.</p>
<pre><code>roll 3d6 + 1d8 + 2</code></pre>
<p>Mostly, Odds/<code>roll</code> is an excuse to freshen up on my OCaml, and especially on the packaging aspect.</p>
<h1 id="code-overview">Code overview</h1>
<p>The code is relatively simple: a dice expression is a function that expects a PRNG state (<code>Random.State.t</code>) and produces a value. The combinators that operate on these simply create new closures that dispatch the PRNG state as needed.</p>
<pre><code>type &#39;a t = Random.State.t -&gt; &#39;a
let lift2 f x y = fun state -&gt;
        let x = roll state x in
        let y = roll state y in
        f x y</code></pre>
<p>The expressions are evaluated by applying the function to a PRNG state. If no state is provided, one is created for the whole of the expression.</p>
<pre><code>let roll ?state t =
        let state = match state with
                | None -&gt; Random.State.make_self_init ()
                | Some state -&gt; state
        in
        t state</code></pre>
<p>Finally, two modules are provided: a monad and a lifting of all of <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Pervasives.html"><code>Pervasives</code></a> integer functions.</p>
<pre><code>module Monad: sig
        val return: &#39;a -&gt; &#39;a t
        val bind: &#39;a t -&gt; (&#39;a -&gt; &#39;b t) -&gt; &#39;b t
        val ( &gt;&gt;= ): &#39;a t -&gt; (&#39;a -&gt; &#39;b t) -&gt; &#39;b t
        val map: &#39;a t -&gt; (&#39;a -&gt; &#39;b) -&gt; &#39;b t
        val ( &gt;|= ): &#39;a t -&gt; (&#39;a -&gt; &#39;b) -&gt; &#39;b t
end
module Algebra: sig
        val ( ! ): int -&gt; int t
        val ( + ): int t -&gt; int t -&gt; int t
        val ( - ): int t -&gt; int t -&gt; int t
    …
end</code></pre>
<h2 id="folding-through-rolls">Folding through rolls</h2>
<p>The version above is a simplification: the library also provides a way to fold through all the dice rolls that happen when an expression is evaluated. There is a <code>roll_fold</code> function:</p>
<pre><code>val roll_fold:
    ?state: Random.State.t -&gt;
    folder: (&#39;acc -&gt; int -&gt; int -&gt; &#39;acc) -&gt;
    init: &#39;acc -&gt;
    &#39;a t -&gt;
    (&#39;a * &#39;acc)</code></pre>
<p>To implement this, the dice expressions take an additional argument:</p>
<pre><code>type &#39;a t = Random.State.t -&gt; (int -&gt; int -&gt; unit) -&gt; &#39;a</code></pre>
<p>And the <code>roll_fold</code> function creates a reference to hold the accumulator, then wraps the folding function into an imperative version that updates the reference:</p>
<pre><code>let roll_fold ?state ~folder ~init t =
        let state = match state with
                | None -&gt; Random.State.make_self_init ()
                | Some state -&gt; state
        in
        let folded = ref init in
        let folder x y = folded := folder !folded x y in
        let result = roll state folder t in
        (result, !folded)
</code></pre>
<p>This is somewhat inelegant and it will probably be changed later.</p>
<h2 id="roll">roll</h2>
<p>The <code>roll</code> companion program simply parses its arguments as a dice expression and calls the library. To parse the arguments, it uses the library parser. Currently, the parser only supports a handful of operators: dice, addition, subtraction, multiplication and division.</p>
<p>A seed can be passed as an additional argument to initialise the PRNG state.</p>
<p>A verbose flag prints all intermediate rolls.</p>
<h1 id="packaging">Packaging</h1>
<p>The main reason to start the project was to refresh on the packaging (and release, etc.) part of OCaml development. This aspect of the OCaml ecosystem has evolved a lot.</p>
<p><a href="http://erratique.ch/software/topkg">Topkg</a> is a packaging tool written by Daniel Bünzli. It takes care of pretty much everything packaging wise. I encountered minor issues, mostly due to inexperience. (I had to force-push to my Github repository because I had forgotten dome files.)</p>
<p>For the release part, I was unable to automatically push to opam because of a missing dependency (<code>opam-publish</code>). I was then unable to install it explicitly because of an unrelated error (I need to unpin Lwt). For now, I simply made a pull request on opam-repository manually.</p>
</div>
</body>
</html>
